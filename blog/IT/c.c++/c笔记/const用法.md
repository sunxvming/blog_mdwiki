总之就是一句话：尽可能多用 const，让代码更安全。


### 一般用法
const int MAXNUM = 100; 
由于常量一旦被创建后其值就不能再改变，所以常量必须在定义的同时赋值（初始化），后面的任何赋值行为都将引发错误。
By Default, const Objects Are Local to a File，在编译的时候就已经被替换了。所有作用域是当前文件。
```    
int n = 90;
const int MaxNum1 = getNum();  //运行时初始化
const int MaxNum2 = n;  //运行时初始化
const int MaxNum3 = 80;  //编译时初始化
```
###   const 和指针，还是就近原则
```
const int *p1;     //指向常量的指针
int * const p3;    //常量指针
```
###   const 和函数形参
const形参好处：
1. 防止在函数内部修改指针指向的数据，就可以用 const 来限制。
2. 清楚的分清参数的输入和输出特性
3. 可以接受const和非const的变量
4. 可以将引用绑定到类型相近的数据，而不仅仅是严格匹配
```
size_t strlen ( const char * str );
```
###   const 和非 const 类型转换
`const char *`和`char *`是不同的类型，不能将`const char *`类型的数据赋值给`char *`类型的变量。但反过来是可以的，编译器允许将`char *`类型的数据赋值给`const char *`类型的变量。
这种限制很容易理解，`char *`指向的数据有读取和写入权限，而`const char *`指向的数据只有读取权限，降低数据的权限不会带来任何问题，但提升数据的权限就有可能发生危险。


### C++ const成员变量和const成员函数（常成员函数）
const 成员变量的用法和普通 const 变量的用法相似，只需要在声明时加上 const 关键字。初始化 const 成员变量只有一种方法，就是通过构造函数的初始化列表


我们通常将 get 函数设置为常成员函数。读取成员变量的函数的名字通常以get开头，后跟成员变量的名字，所以通常将它们称为 get 函数。
需要强调的是，必须在成员函数的声明和定义处**同时加上**`const` 关键字。`char *getname() const`和`char *getname()`是两个不同的函数原型，如果只在一个地方加 const 会导致声明和定义处的函数原型冲突。


* 函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改，例如`const char * getname()`。
* 函数头部的结尾加上 const 表示常成员函数，此时的const是修饰的this指针，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如`char * getname() const`。
### C++ const对象（常对象）
`const  class  object(params);`
只能调用类的const成员（包括 const 成员变量和 const 成员函数）了


### 编译器会为**const引用**创建临时变量
将常引用绑定到临时数据时，编译器采取了一种妥协机制：编译器会为临时数据创建一个新的、无名的临时变量，并将临时数据放入该临时变量中，然后再将引用绑定到该临时变量。注意，临时变量也是变量，所有的变量都会被分配内存。
### C++const和引用
不同类型的数据占用的内存数量不一样，处理方式也不一样，指针的类型要与它指向的数据的类型严格对应。
引用（Reference）和指针（Pointer）在本质上是一样的，引用仅仅是对指针进行了简单的封装，「类型严格一致」这条规则同样也适用于引用。
但给引用添加 const 限定后，不但可以将引用绑定到临时数据，还可以将引用绑定到类型相近的数据，这使得引用更加灵活和通用，它们背后的机制都是临时变量。


概括起来说，将引用类型的形参添加 const 限制的理由有三个：
* 使用 const 可以避免无意中修改数据的编程错误；
* 使用 const 能让函数接收 const 和非 const 类型的实参，否则将只能接收非 const 类型的实参；
* 使用 const 引用能够让函数正确生成并使用临时变量（可以将引用绑定到类型相近的数据，而不仅仅是严格匹配）。



